package com.yyc.bes.admin.config.bes;

import cn.hutool.core.io.IoUtil;
import com.alibaba.fastjson.annotation.JSONField;
import com.yyc.bes.admin.support.ZipSupport;
import com.yyc.bes.admin.util.BusinessUtil;
import com.yyc.bes.admin.util.ZipPointDownloadUtil;
import com.yyc.common.exception.BusinessException;
import lombok.Data;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.zip.CRC32;

public class test {
    //定义一个zip文件头的常量
    private static final byte[] ZIP_HEADER = new byte[]{0x50, 0x4b, 0x03, 0x04};

    //定义一个zip文件尾的常量
    private static final byte[] ZIP_FOOTER = new byte[]{0x50, 0x4b, 0x05, 0x06};

    //定义一个zip目录项的常量
    private static final byte[] ZIP_ENTRY = new byte[]{0x50, 0x4b, 0x01, 0x02};
    //把单个文件添加到zip中的方法，接收一个文件作为参数
    public static void zipFile(ZipEntryInfo zipEntryInfo, Long skipBytes, OutputStream outputStream) throws IOException {
        File file = new File(zipEntryInfo.getFilePath());
        String name = zipEntryInfo.getName(); //获取文件名
        long size = zipEntryInfo.getSize(); //获取文件大小
        long crc32 = getCRC32(new File(zipEntryInfo.getFilePath())); //调用getCRC32方法，获取文件的CRC32校验码
        zipEntryInfo.setCrc32(crc32);
        byte[] bytes = getWriteZipHeader(name, size, crc32);
        if(skipBytes >= bytes.length){
            skipBytes = skipBytes-bytes.length;
            try (FileInputStream fis = new FileInputStream(file)){
                fis.skip(skipBytes);
                IoUtil.copy(fis,outputStream);
            }
        }else{
            byte[] newBytes = new byte[bytes.length-skipBytes.intValue()];
            System.arraycopy(bytes,0,newBytes,0,bytes.length-skipBytes.intValue());
            outputStream.write(newBytes);
            try (FileInputStream fis = new FileInputStream(file)){
                IoUtil.copy(fis,outputStream);
            }
        }
    }

    //写入zip文件头的方法，接收文件名、大小和CRC32校验码作为参数
    private static byte[] getWriteZipHeader(String name, long size, long crc32){
        byte[] bytes = new byte[30+name.getBytes().length];
        addBytes(bytes,ZIP_HEADER,0,3);
        addBytes(bytes,revert(new byte[]{0, 0x0a}),4,5);
        addBytes(bytes,revert(new byte[]{8, 0}),6,7);
        addBytes(bytes,revert(new byte[]{0, 0}),8,9);
        addBytes(bytes,revert(intToBytes(0)),10,11);
        addBytes(bytes,revert(intToBytes(0)),12,13);
        addBytes(bytes,revert(longToBytes(crc32)),14,17);
        addBytes(bytes,revert(longToBytes(size)),18,21);
        addBytes(bytes,revert(longToBytes(size)),22,25);
        addBytes(bytes,revert(intToBytes(name.getBytes().length)),26,27);
        addBytes(bytes,revert(intToBytes(0)),28,29);
        addBytes(bytes,name.getBytes(),30,30+name.getBytes().length-1);
        return bytes;
    }
    private static void addBytes(byte[] bytes,byte[] addBytes,int start,int end){
        for (int i = start; i <= end; i++) {
            bytes[i] = addBytes[i-start];
        }
    }

    //写入zip目录项的方法，接收一个ZipEntryInfo对象作为参数
    private static byte[] getWriteZipEntry(ZipEntryInfo entry){
        String name = entry.getName();
        byte[] bytes = new byte[46+name.getBytes().length];
        addBytes(bytes,ZIP_ENTRY,0,3);
        addBytes(bytes,revert(new byte[]{0, 0x0a}),4,5);
        addBytes(bytes,revert(new byte[]{0, 0x0a}),6,7);
        addBytes(bytes,revert(new byte[]{8, 0}),8,9);
        addBytes(bytes,revert(intToBytes(0)),10,11);
        addBytes(bytes,revert(intToBytes(0)),12,13);
        addBytes(bytes,revert(intToBytes(0)),14,15);
        addBytes(bytes,revert(longToBytes(entry.getOrGenCrc32())),16,19);
        addBytes(bytes,revert(longToBytes(entry.getSize())),20,23);
        addBytes(bytes,revert(longToBytes(entry.getSize())),24,27);
        addBytes(bytes,revert(intToBytes(entry.getName().getBytes().length)),28,29);
        addBytes(bytes,revert(intToBytes(0)),30,31);
        addBytes(bytes,revert(intToBytes(0)),32,33);
        addBytes(bytes,revert(intToBytes(0)),34,35);
        addBytes(bytes,revert(intToBytes(0)),36,37);
        addBytes(bytes,revert(longToBytes(0L)),38,41);
        addBytes(bytes,revert(longToBytes(entry.getOffset())),42,45);
        addBytes(bytes,entry.getName().getBytes(),46,46+entry.getName().getBytes().length-1);
        return bytes;
    }
    //写入zip文件尾的方法，无参数
    public static void writeZipFooter(List<ZipEntryInfo> zipEntryInfoList, Long skipBytes, OutputStream outputStream) throws IOException {
        ZipEntryInfo zipEntryInfo = zipEntryInfoList.get(zipEntryInfoList.size() - 1);
        long start =zipEntryInfo.getNextOffset(); //获取当前zip输出流的大小，作为目录开始位置
        long end =zipEntryInfo.getNextOffset(); //获取当前zip输出流的大小，作为目录开始位置
        for (ZipEntryInfo entry : zipEntryInfoList) { //遍历列表中的每个ZipEntryInfo对象
            byte[] bytes = getWriteZipEntry(entry);
            if(skipBytes>=bytes.length){
                skipBytes = skipBytes - bytes.length;
            }else{
                if(skipBytes>0){
                    byte[] newBytes = new byte[bytes.length-skipBytes.intValue()];
                    System.arraycopy(bytes,0,newBytes,0,bytes.length-skipBytes.intValue());
                    outputStream.write(newBytes);
                    skipBytes = 0L;
                }else{
                    outputStream.write(bytes);
                }
            }
            end+= 46 + entry.getName().getBytes().length;
        }
        long size = end - start; //计算目录的大小
        byte[] bytes = new byte[22];
        addBytes(bytes,ZIP_FOOTER,0,3);
        addBytes(bytes,revert(new byte[]{0, 0}),4,5);
        addBytes(bytes,revert(new byte[]{0, 0}),6,7);
        addBytes(bytes,revert(intToBytes(zipEntryInfoList.size())),8,9);
        addBytes(bytes,revert(intToBytes(zipEntryInfoList.size())),10,11);
        addBytes(bytes,revert(longToBytes(size)),12,15);
        addBytes(bytes,revert(longToBytes(start)),16,19);
        addBytes(bytes,revert(new byte[]{0, 0}),20,21);
        if(skipBytes>0){
            byte[] newBytes = new byte[bytes.length-skipBytes.intValue()];
            System.arraycopy(bytes,0,newBytes,0,bytes.length-skipBytes.intValue());
            outputStream.write(newBytes);
        }else{
            outputStream.write(bytes);
        }
    }

    public static long getZipFileSize(List<ZipEntryInfo> zipEntryInfoList){
        long size = zipEntryInfoList.get(zipEntryInfoList.size() - 1).getNextOffset();
        for (ZipEntryInfo entry : zipEntryInfoList) { //遍历列表中的每个ZipEntryInfo对象
            size+= 46 + entry.getName().getBytes().length;
        }
        return size+22;
    }

    public static Date getZipLastUpdate(List<ZipEntryInfo> zipEntryInfoList){
        File file = new File(zipEntryInfoList.get(zipEntryInfoList.size() - 1).getFilePath());
        return new Date(file.lastModified());
    }




    //获取文件的CRC32校验码的方法，接收一个文件作为参数，返回一个整数
    public static long getCRC32(File file) throws IOException {
        CRC32 crc = new CRC32(); //创建一个CRC32对象，用于计算校验码
        try (FileInputStream fis = new FileInputStream(file)){
            //创建一个文件输入流，读取文件内容
            byte[] buffer = new byte[8192]; //创建一个缓冲区，用于存储读取的字节
            int len; //定义一个变量，用于记录读取的字节数
            while ((len = fis.read(buffer)) != -1) { //循环读取文件内容，直到结束
                crc.update(buffer, 0, len); //把读取的字节更新到CRC32对象中
            }
        }
        return  crc.getValue(); //返回CRC32对象的值，转换为整数
    }

    //把整数转换为字节数组的方法，接收一个整数作为参数，返回一个长度为2的字节数组
    private static byte[] intToBytes(int value) {
        return new byte[]{(byte) ((value >> 8) & 0xff),(byte) (value & 0xff)};
    }

    private static byte[] longToBytes(long value) {
        return new byte[]{(byte) ((value >> 24) & 0xff),(byte) ((value >> 16) & 0xff),(byte) ((value >> 8) & 0xff),(byte) (value & 0xff)};
    }
    private static byte[] revert(byte[] bytes) {
        byte[] ret = new byte[bytes.length];
        int index = bytes.length - 1 ;
        for (byte aByte : bytes) {
            ret[index] = aByte;
            index--;
        }
        return ret;
    }

    @Data
    public static class ZipEntryInfo {
        private String name;
        private long size;
        private long offset;
        private long nextOffset;
        private long crc32;
        private String filePath;

        public ZipEntryInfo() {
        }

        public ZipEntryInfo(String name, long size, long offset, long crc32) {
            this.name = name;
            this.size = size;
            this.offset = offset;
            this.crc32 = crc32;
        }

        public ZipEntryInfo(String name, long size, long offset,String filePath) {
            this.name = name;
            this.size = size;
            this.offset = offset;
            this.filePath = filePath;
        }

        @JSONField(serialize = false)
        public long getOrGenCrc32() {
            if(crc32==0L){
                try {
                    this.crc32 = getCRC32(new File(filePath));
                } catch (IOException e) {
                    throw new BusinessException("获取文件的crc32失败");
                }
            }
            return crc32;
        }

    }


    public void zipFileChannelEntry(HttpServletRequest request, HttpServletResponse response, OutputStream outputStream, List<ZipEntryInfo> zipEntryInfos, String fileName) throws Exception{
        long zipFileSize = getZipFileSize(zipEntryInfos);
        int index = 0;
        long skipByte = 0L;
        // 设置响应头，告诉浏览器是下载文件
        response.setHeader("Accept-Ranges", "bytes");
        response.setHeader("Last-Modified", getZipLastUpdate(zipEntryInfos).toString());
        response.setContentType("application/octet-stream");
        response.setHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(fileName, "UTF-8"));
        if (request != null && request.getHeader("range") != null) {
            // 断点续传
            String[] range = request.getHeader("range").replaceAll("[^0-9\\-]", "").split("-");
            // 文件总大小
            // 下载起始位置
            long startByte = Long.parseLong(range[0]);
            for (int i = 0; i < zipEntryInfos.size(); i++) {
                ZipEntryInfo zipEntryInfo = zipEntryInfos.get(i);
                if(zipEntryInfo.getNextOffset()>startByte){
                    skipByte = startByte-zipEntryInfo.getOffset();
                    index = i;
                    break;
                }else if(i==zipEntryInfos.size()-1){
                    skipByte = startByte-zipEntryInfo.getNextOffset();
                    index = zipEntryInfos.size();
                }
            }
            // 设置响应头，表示响应的字节范围和文件总长度
            response.setHeader("Content-Range", "bytes " + startByte + "-" + (zipFileSize - 1) + "/" + zipFileSize);
            response.setContentLengthLong(zipFileSize-startByte);
            response.setStatus(206);
        }else{
            response.setContentLengthLong(zipFileSize);
            BusinessUtil.addResponseFileHeader(response, fileName);
            response.setStatus(200);
        }
        if(zipEntryInfos.size()>index-1){
            for (int i = index; i < zipEntryInfos.size(); i++) {
                ZipEntryInfo zipEntryInfo = zipEntryInfos.get(i);
                zipFile(zipEntryInfo,skipByte,outputStream);
                skipByte = 0L;
            }
        }
        writeZipFooter(zipEntryInfos,skipByte,outputStream);
    }
}
